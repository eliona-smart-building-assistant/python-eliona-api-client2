# coding: utf-8

"""
    Eliona REST API

    The Eliona REST API enables unified access to the resources and data of an Eliona environment.

    The version of the OpenAPI document: 2.9.6
    Contact: hello@eliona.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from eliona.api_client2.models.data import Data
from eliona.api_client2.models.data_aggregated import DataAggregated
from eliona.api_client2.models.data_listen import DataListen
from eliona.api_client2.models.data_trend_aggregated import DataTrendAggregated

from eliona.api_client2.api_client import ApiClient, RequestSerialized
from eliona.api_client2.api_response import ApiResponse
from eliona.api_client2.rest import RESTResponseType


class DataApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_data(
        self,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        parent_asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific parent asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        asset_type_name: Annotated[Optional[StrictStr], Field(description="Filter the name of the asset type")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Specifies the starting point for pagination by indicating the number of items to skip. ")] = None,
        size: Annotated[Optional[StrictInt], Field(description="Specifies the number of items per page for pagination. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Data]:
        """Gets all data

        Gets information about data for assets.

        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param parent_asset_id: Filter for a specific parent asset id
        :type parent_asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param asset_type_name: Filter the name of the asset type
        :type asset_type_name: str
        :param offset: Specifies the starting point for pagination by indicating the number of items to skip. 
        :type offset: int
        :param size: Specifies the number of items per page for pagination. 
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_serialize(
            asset_id=asset_id,
            parent_asset_id=parent_asset_id,
            data_subtype=data_subtype,
            asset_type_name=asset_type_name,
            offset=offset,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Data]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_with_http_info(
        self,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        parent_asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific parent asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        asset_type_name: Annotated[Optional[StrictStr], Field(description="Filter the name of the asset type")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Specifies the starting point for pagination by indicating the number of items to skip. ")] = None,
        size: Annotated[Optional[StrictInt], Field(description="Specifies the number of items per page for pagination. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Data]]:
        """Gets all data

        Gets information about data for assets.

        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param parent_asset_id: Filter for a specific parent asset id
        :type parent_asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param asset_type_name: Filter the name of the asset type
        :type asset_type_name: str
        :param offset: Specifies the starting point for pagination by indicating the number of items to skip. 
        :type offset: int
        :param size: Specifies the number of items per page for pagination. 
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_serialize(
            asset_id=asset_id,
            parent_asset_id=parent_asset_id,
            data_subtype=data_subtype,
            asset_type_name=asset_type_name,
            offset=offset,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Data]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_without_preload_content(
        self,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        parent_asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific parent asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        asset_type_name: Annotated[Optional[StrictStr], Field(description="Filter the name of the asset type")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Specifies the starting point for pagination by indicating the number of items to skip. ")] = None,
        size: Annotated[Optional[StrictInt], Field(description="Specifies the number of items per page for pagination. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets all data

        Gets information about data for assets.

        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param parent_asset_id: Filter for a specific parent asset id
        :type parent_asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param asset_type_name: Filter the name of the asset type
        :type asset_type_name: str
        :param offset: Specifies the starting point for pagination by indicating the number of items to skip. 
        :type offset: int
        :param size: Specifies the number of items per page for pagination. 
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_serialize(
            asset_id=asset_id,
            parent_asset_id=parent_asset_id,
            data_subtype=data_subtype,
            asset_type_name=asset_type_name,
            offset=offset,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Data]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_serialize(
        self,
        asset_id,
        parent_asset_id,
        data_subtype,
        asset_type_name,
        offset,
        size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if parent_asset_id is not None:
            
            _query_params.append(('parentAssetId', parent_asset_id))
            
        if data_subtype is not None:
            
            _query_params.append(('dataSubtype', data_subtype))
            
        if asset_type_name is not None:
            
            _query_params.append(('assetTypeName', asset_type_name))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/x-ndjson'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data_aggregated(
        self,
        from_date: Annotated[Optional[StrictStr], Field(description="Filter by lower date time (RFC3339) limit inclusive")] = None,
        to_date: Annotated[Optional[StrictStr], Field(description="Filter by upper date time (RFC3339) limit exclusive")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        asset_type_name: Annotated[Optional[StrictStr], Field(description="Filter the name of the asset type")] = None,
        aggregation_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific aggregation id")] = None,
        aggregation_raster: Annotated[Optional[StrictStr], Field(description="Aggregation calculation interval")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DataAggregated]:
        """(Deprecated) Get aggregated data

        Deprecated: Use the 'GET /data-trend-aggregated' endpoint to retrieve aggregated data for periodic rasters without defining aggregations. Gets aggregated data sets which combines a set of data points for a defined periodical raster. 

        :param from_date: Filter by lower date time (RFC3339) limit inclusive
        :type from_date: str
        :param to_date: Filter by upper date time (RFC3339) limit exclusive
        :type to_date: str
        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param asset_type_name: Filter the name of the asset type
        :type asset_type_name: str
        :param aggregation_id: Filter for a specific aggregation id
        :type aggregation_id: int
        :param aggregation_raster: Aggregation calculation interval
        :type aggregation_raster: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /data-aggregated is deprecated.", DeprecationWarning)

        _param = self._get_data_aggregated_serialize(
            from_date=from_date,
            to_date=to_date,
            asset_id=asset_id,
            data_subtype=data_subtype,
            asset_type_name=asset_type_name,
            aggregation_id=aggregation_id,
            aggregation_raster=aggregation_raster,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataAggregated]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_aggregated_with_http_info(
        self,
        from_date: Annotated[Optional[StrictStr], Field(description="Filter by lower date time (RFC3339) limit inclusive")] = None,
        to_date: Annotated[Optional[StrictStr], Field(description="Filter by upper date time (RFC3339) limit exclusive")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        asset_type_name: Annotated[Optional[StrictStr], Field(description="Filter the name of the asset type")] = None,
        aggregation_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific aggregation id")] = None,
        aggregation_raster: Annotated[Optional[StrictStr], Field(description="Aggregation calculation interval")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DataAggregated]]:
        """(Deprecated) Get aggregated data

        Deprecated: Use the 'GET /data-trend-aggregated' endpoint to retrieve aggregated data for periodic rasters without defining aggregations. Gets aggregated data sets which combines a set of data points for a defined periodical raster. 

        :param from_date: Filter by lower date time (RFC3339) limit inclusive
        :type from_date: str
        :param to_date: Filter by upper date time (RFC3339) limit exclusive
        :type to_date: str
        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param asset_type_name: Filter the name of the asset type
        :type asset_type_name: str
        :param aggregation_id: Filter for a specific aggregation id
        :type aggregation_id: int
        :param aggregation_raster: Aggregation calculation interval
        :type aggregation_raster: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /data-aggregated is deprecated.", DeprecationWarning)

        _param = self._get_data_aggregated_serialize(
            from_date=from_date,
            to_date=to_date,
            asset_id=asset_id,
            data_subtype=data_subtype,
            asset_type_name=asset_type_name,
            aggregation_id=aggregation_id,
            aggregation_raster=aggregation_raster,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataAggregated]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_aggregated_without_preload_content(
        self,
        from_date: Annotated[Optional[StrictStr], Field(description="Filter by lower date time (RFC3339) limit inclusive")] = None,
        to_date: Annotated[Optional[StrictStr], Field(description="Filter by upper date time (RFC3339) limit exclusive")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        asset_type_name: Annotated[Optional[StrictStr], Field(description="Filter the name of the asset type")] = None,
        aggregation_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific aggregation id")] = None,
        aggregation_raster: Annotated[Optional[StrictStr], Field(description="Aggregation calculation interval")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get aggregated data

        Deprecated: Use the 'GET /data-trend-aggregated' endpoint to retrieve aggregated data for periodic rasters without defining aggregations. Gets aggregated data sets which combines a set of data points for a defined periodical raster. 

        :param from_date: Filter by lower date time (RFC3339) limit inclusive
        :type from_date: str
        :param to_date: Filter by upper date time (RFC3339) limit exclusive
        :type to_date: str
        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param asset_type_name: Filter the name of the asset type
        :type asset_type_name: str
        :param aggregation_id: Filter for a specific aggregation id
        :type aggregation_id: int
        :param aggregation_raster: Aggregation calculation interval
        :type aggregation_raster: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /data-aggregated is deprecated.", DeprecationWarning)

        _param = self._get_data_aggregated_serialize(
            from_date=from_date,
            to_date=to_date,
            asset_id=asset_id,
            data_subtype=data_subtype,
            asset_type_name=asset_type_name,
            aggregation_id=aggregation_id,
            aggregation_raster=aggregation_raster,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataAggregated]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_aggregated_serialize(
        self,
        from_date,
        to_date,
        asset_id,
        data_subtype,
        asset_type_name,
        aggregation_id,
        aggregation_raster,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        if to_date is not None:
            
            _query_params.append(('toDate', to_date))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if data_subtype is not None:
            
            _query_params.append(('dataSubtype', data_subtype))
            
        if asset_type_name is not None:
            
            _query_params.append(('assetTypeName', asset_type_name))
            
        if aggregation_id is not None:
            
            _query_params.append(('aggregationId', aggregation_id))
            
        if aggregation_raster is not None:
            
            _query_params.append(('aggregationRaster', aggregation_raster))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-aggregated',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data_trend_aggregated_by_id(
        self,
        asset_id: Annotated[StrictInt, Field(description="The id of the asset")],
        data_subtype: Annotated[StrictStr, Field(description="Type of asset data")],
        attribute_name: Annotated[StrictStr, Field(description="Data attribute name")],
        aggregation_raster: Annotated[StrictStr, Field(description="Aggregation calculation period")],
        from_date: Annotated[StrictStr, Field(description="Lower date time (RFC3339) limit inclusive")],
        to_date: Annotated[StrictStr, Field(description="Upper date time (RFC3339) limit inclusive")],
        sum_method: Annotated[Optional[StrictStr], Field(description="Method for summarize data")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Specifies the starting point for pagination by indicating the number of items to skip. ")] = None,
        size: Annotated[Optional[StrictInt], Field(description="Specifies the number of items per page for pagination. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DataTrendAggregated]:
        """Get aggregated trend of historical data

        Gets aggregated trend of historical data for a period and time grid for an asset

        :param asset_id: The id of the asset (required)
        :type asset_id: int
        :param data_subtype: Type of asset data (required)
        :type data_subtype: str
        :param attribute_name: Data attribute name (required)
        :type attribute_name: str
        :param aggregation_raster: Aggregation calculation period (required)
        :type aggregation_raster: str
        :param from_date: Lower date time (RFC3339) limit inclusive (required)
        :type from_date: str
        :param to_date: Upper date time (RFC3339) limit inclusive (required)
        :type to_date: str
        :param sum_method: Method for summarize data
        :type sum_method: str
        :param offset: Specifies the starting point for pagination by indicating the number of items to skip. 
        :type offset: int
        :param size: Specifies the number of items per page for pagination. 
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_trend_aggregated_by_id_serialize(
            asset_id=asset_id,
            data_subtype=data_subtype,
            attribute_name=attribute_name,
            aggregation_raster=aggregation_raster,
            from_date=from_date,
            to_date=to_date,
            sum_method=sum_method,
            offset=offset,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataTrendAggregated]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_trend_aggregated_by_id_with_http_info(
        self,
        asset_id: Annotated[StrictInt, Field(description="The id of the asset")],
        data_subtype: Annotated[StrictStr, Field(description="Type of asset data")],
        attribute_name: Annotated[StrictStr, Field(description="Data attribute name")],
        aggregation_raster: Annotated[StrictStr, Field(description="Aggregation calculation period")],
        from_date: Annotated[StrictStr, Field(description="Lower date time (RFC3339) limit inclusive")],
        to_date: Annotated[StrictStr, Field(description="Upper date time (RFC3339) limit inclusive")],
        sum_method: Annotated[Optional[StrictStr], Field(description="Method for summarize data")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Specifies the starting point for pagination by indicating the number of items to skip. ")] = None,
        size: Annotated[Optional[StrictInt], Field(description="Specifies the number of items per page for pagination. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DataTrendAggregated]]:
        """Get aggregated trend of historical data

        Gets aggregated trend of historical data for a period and time grid for an asset

        :param asset_id: The id of the asset (required)
        :type asset_id: int
        :param data_subtype: Type of asset data (required)
        :type data_subtype: str
        :param attribute_name: Data attribute name (required)
        :type attribute_name: str
        :param aggregation_raster: Aggregation calculation period (required)
        :type aggregation_raster: str
        :param from_date: Lower date time (RFC3339) limit inclusive (required)
        :type from_date: str
        :param to_date: Upper date time (RFC3339) limit inclusive (required)
        :type to_date: str
        :param sum_method: Method for summarize data
        :type sum_method: str
        :param offset: Specifies the starting point for pagination by indicating the number of items to skip. 
        :type offset: int
        :param size: Specifies the number of items per page for pagination. 
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_trend_aggregated_by_id_serialize(
            asset_id=asset_id,
            data_subtype=data_subtype,
            attribute_name=attribute_name,
            aggregation_raster=aggregation_raster,
            from_date=from_date,
            to_date=to_date,
            sum_method=sum_method,
            offset=offset,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataTrendAggregated]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_trend_aggregated_by_id_without_preload_content(
        self,
        asset_id: Annotated[StrictInt, Field(description="The id of the asset")],
        data_subtype: Annotated[StrictStr, Field(description="Type of asset data")],
        attribute_name: Annotated[StrictStr, Field(description="Data attribute name")],
        aggregation_raster: Annotated[StrictStr, Field(description="Aggregation calculation period")],
        from_date: Annotated[StrictStr, Field(description="Lower date time (RFC3339) limit inclusive")],
        to_date: Annotated[StrictStr, Field(description="Upper date time (RFC3339) limit inclusive")],
        sum_method: Annotated[Optional[StrictStr], Field(description="Method for summarize data")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Specifies the starting point for pagination by indicating the number of items to skip. ")] = None,
        size: Annotated[Optional[StrictInt], Field(description="Specifies the number of items per page for pagination. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get aggregated trend of historical data

        Gets aggregated trend of historical data for a period and time grid for an asset

        :param asset_id: The id of the asset (required)
        :type asset_id: int
        :param data_subtype: Type of asset data (required)
        :type data_subtype: str
        :param attribute_name: Data attribute name (required)
        :type attribute_name: str
        :param aggregation_raster: Aggregation calculation period (required)
        :type aggregation_raster: str
        :param from_date: Lower date time (RFC3339) limit inclusive (required)
        :type from_date: str
        :param to_date: Upper date time (RFC3339) limit inclusive (required)
        :type to_date: str
        :param sum_method: Method for summarize data
        :type sum_method: str
        :param offset: Specifies the starting point for pagination by indicating the number of items to skip. 
        :type offset: int
        :param size: Specifies the number of items per page for pagination. 
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_trend_aggregated_by_id_serialize(
            asset_id=asset_id,
            data_subtype=data_subtype,
            attribute_name=attribute_name,
            aggregation_raster=aggregation_raster,
            from_date=from_date,
            to_date=to_date,
            sum_method=sum_method,
            offset=offset,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataTrendAggregated]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_trend_aggregated_by_id_serialize(
        self,
        asset_id,
        data_subtype,
        attribute_name,
        aggregation_raster,
        from_date,
        to_date,
        sum_method,
        offset,
        size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if asset_id is not None:
            _path_params['asset-id'] = asset_id
        # process the query parameters
        if data_subtype is not None:
            
            _query_params.append(('dataSubtype', data_subtype))
            
        if attribute_name is not None:
            
            _query_params.append(('attributeName', attribute_name))
            
        if aggregation_raster is not None:
            
            _query_params.append(('aggregationRaster', aggregation_raster))
            
        if sum_method is not None:
            
            _query_params.append(('sumMethod', sum_method))
            
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        if to_date is not None:
            
            _query_params.append(('toDate', to_date))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-trend-aggregated/{asset-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data_trend_by_id(
        self,
        asset_id: Annotated[StrictInt, Field(description="The id of the asset")],
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        attribute_name: Annotated[Optional[StrictStr], Field(description="Data attribute name")] = None,
        from_date: Annotated[Optional[StrictStr], Field(description="Filter by lower date time (RFC3339) limit inclusive")] = None,
        to_date: Annotated[Optional[StrictStr], Field(description="Filter by upper date time (RFC3339) limit exclusive")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Specifies the starting point for pagination by indicating the number of items to skip. ")] = None,
        size: Annotated[Optional[StrictInt], Field(description="Specifies the number of items per page for pagination. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Data]:
        """Get trend of historical data

        Gets trend information about historical data for an asset

        :param asset_id: The id of the asset (required)
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param attribute_name: Data attribute name
        :type attribute_name: str
        :param from_date: Filter by lower date time (RFC3339) limit inclusive
        :type from_date: str
        :param to_date: Filter by upper date time (RFC3339) limit exclusive
        :type to_date: str
        :param offset: Specifies the starting point for pagination by indicating the number of items to skip. 
        :type offset: int
        :param size: Specifies the number of items per page for pagination. 
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_trend_by_id_serialize(
            asset_id=asset_id,
            data_subtype=data_subtype,
            attribute_name=attribute_name,
            from_date=from_date,
            to_date=to_date,
            offset=offset,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Data]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_trend_by_id_with_http_info(
        self,
        asset_id: Annotated[StrictInt, Field(description="The id of the asset")],
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        attribute_name: Annotated[Optional[StrictStr], Field(description="Data attribute name")] = None,
        from_date: Annotated[Optional[StrictStr], Field(description="Filter by lower date time (RFC3339) limit inclusive")] = None,
        to_date: Annotated[Optional[StrictStr], Field(description="Filter by upper date time (RFC3339) limit exclusive")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Specifies the starting point for pagination by indicating the number of items to skip. ")] = None,
        size: Annotated[Optional[StrictInt], Field(description="Specifies the number of items per page for pagination. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Data]]:
        """Get trend of historical data

        Gets trend information about historical data for an asset

        :param asset_id: The id of the asset (required)
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param attribute_name: Data attribute name
        :type attribute_name: str
        :param from_date: Filter by lower date time (RFC3339) limit inclusive
        :type from_date: str
        :param to_date: Filter by upper date time (RFC3339) limit exclusive
        :type to_date: str
        :param offset: Specifies the starting point for pagination by indicating the number of items to skip. 
        :type offset: int
        :param size: Specifies the number of items per page for pagination. 
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_trend_by_id_serialize(
            asset_id=asset_id,
            data_subtype=data_subtype,
            attribute_name=attribute_name,
            from_date=from_date,
            to_date=to_date,
            offset=offset,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Data]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_trend_by_id_without_preload_content(
        self,
        asset_id: Annotated[StrictInt, Field(description="The id of the asset")],
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        attribute_name: Annotated[Optional[StrictStr], Field(description="Data attribute name")] = None,
        from_date: Annotated[Optional[StrictStr], Field(description="Filter by lower date time (RFC3339) limit inclusive")] = None,
        to_date: Annotated[Optional[StrictStr], Field(description="Filter by upper date time (RFC3339) limit exclusive")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Specifies the starting point for pagination by indicating the number of items to skip. ")] = None,
        size: Annotated[Optional[StrictInt], Field(description="Specifies the number of items per page for pagination. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get trend of historical data

        Gets trend information about historical data for an asset

        :param asset_id: The id of the asset (required)
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param attribute_name: Data attribute name
        :type attribute_name: str
        :param from_date: Filter by lower date time (RFC3339) limit inclusive
        :type from_date: str
        :param to_date: Filter by upper date time (RFC3339) limit exclusive
        :type to_date: str
        :param offset: Specifies the starting point for pagination by indicating the number of items to skip. 
        :type offset: int
        :param size: Specifies the number of items per page for pagination. 
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_trend_by_id_serialize(
            asset_id=asset_id,
            data_subtype=data_subtype,
            attribute_name=attribute_name,
            from_date=from_date,
            to_date=to_date,
            offset=offset,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Data]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_trend_by_id_serialize(
        self,
        asset_id,
        data_subtype,
        attribute_name,
        from_date,
        to_date,
        offset,
        size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if asset_id is not None:
            _path_params['asset-id'] = asset_id
        # process the query parameters
        if data_subtype is not None:
            
            _query_params.append(('dataSubtype', data_subtype))
            
        if attribute_name is not None:
            
            _query_params.append(('attributeName', attribute_name))
            
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        if to_date is not None:
            
            _query_params.append(('toDate', to_date))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/x-ndjson'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-trend/{asset-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data_trends(
        self,
        from_date: Annotated[Optional[StrictStr], Field(description="Filter by lower date time (RFC3339) limit inclusive")] = None,
        to_date: Annotated[Optional[StrictStr], Field(description="Filter by upper date time (RFC3339) limit exclusive")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        asset_type_name: Annotated[Optional[StrictStr], Field(description="Filter the name of the asset type")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Data]:
        """(Deprecated) Get trend of historical data

        Deprecated: Use 'GET /data-trend/{asset-id}' instead. Gets trend information about historical data for assets. 

        :param from_date: Filter by lower date time (RFC3339) limit inclusive
        :type from_date: str
        :param to_date: Filter by upper date time (RFC3339) limit exclusive
        :type to_date: str
        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param asset_type_name: Filter the name of the asset type
        :type asset_type_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /data-trends is deprecated.", DeprecationWarning)

        _param = self._get_data_trends_serialize(
            from_date=from_date,
            to_date=to_date,
            asset_id=asset_id,
            data_subtype=data_subtype,
            asset_type_name=asset_type_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Data]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_trends_with_http_info(
        self,
        from_date: Annotated[Optional[StrictStr], Field(description="Filter by lower date time (RFC3339) limit inclusive")] = None,
        to_date: Annotated[Optional[StrictStr], Field(description="Filter by upper date time (RFC3339) limit exclusive")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        asset_type_name: Annotated[Optional[StrictStr], Field(description="Filter the name of the asset type")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Data]]:
        """(Deprecated) Get trend of historical data

        Deprecated: Use 'GET /data-trend/{asset-id}' instead. Gets trend information about historical data for assets. 

        :param from_date: Filter by lower date time (RFC3339) limit inclusive
        :type from_date: str
        :param to_date: Filter by upper date time (RFC3339) limit exclusive
        :type to_date: str
        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param asset_type_name: Filter the name of the asset type
        :type asset_type_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /data-trends is deprecated.", DeprecationWarning)

        _param = self._get_data_trends_serialize(
            from_date=from_date,
            to_date=to_date,
            asset_id=asset_id,
            data_subtype=data_subtype,
            asset_type_name=asset_type_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Data]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_trends_without_preload_content(
        self,
        from_date: Annotated[Optional[StrictStr], Field(description="Filter by lower date time (RFC3339) limit inclusive")] = None,
        to_date: Annotated[Optional[StrictStr], Field(description="Filter by upper date time (RFC3339) limit exclusive")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        asset_type_name: Annotated[Optional[StrictStr], Field(description="Filter the name of the asset type")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get trend of historical data

        Deprecated: Use 'GET /data-trend/{asset-id}' instead. Gets trend information about historical data for assets. 

        :param from_date: Filter by lower date time (RFC3339) limit inclusive
        :type from_date: str
        :param to_date: Filter by upper date time (RFC3339) limit exclusive
        :type to_date: str
        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param asset_type_name: Filter the name of the asset type
        :type asset_type_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /data-trends is deprecated.", DeprecationWarning)

        _param = self._get_data_trends_serialize(
            from_date=from_date,
            to_date=to_date,
            asset_id=asset_id,
            data_subtype=data_subtype,
            asset_type_name=asset_type_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Data]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_trends_serialize(
        self,
        from_date,
        to_date,
        asset_id,
        data_subtype,
        asset_type_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        if to_date is not None:
            
            _query_params.append(('toDate', to_date))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if data_subtype is not None:
            
            _query_params.append(('dataSubtype', data_subtype))
            
        if asset_type_name is not None:
            
            _query_params.append(('assetTypeName', asset_type_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-trends',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def listen_data(
        self,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataListen:
        """WebSocket connection for asset data changes

        Open a WebSocket connection to get informed when new asset data is written or anything changes.

        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._listen_data_serialize(
            asset_id=asset_id,
            data_subtype=data_subtype,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataListen",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def listen_data_with_http_info(
        self,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataListen]:
        """WebSocket connection for asset data changes

        Open a WebSocket connection to get informed when new asset data is written or anything changes.

        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._listen_data_serialize(
            asset_id=asset_id,
            data_subtype=data_subtype,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataListen",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def listen_data_without_preload_content(
        self,
        asset_id: Annotated[Optional[StrictInt], Field(description="Filter for a specific asset id")] = None,
        data_subtype: Annotated[Optional[StrictStr], Field(description="Filter for a specific type of asset data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """WebSocket connection for asset data changes

        Open a WebSocket connection to get informed when new asset data is written or anything changes.

        :param asset_id: Filter for a specific asset id
        :type asset_id: int
        :param data_subtype: Filter for a specific type of asset data
        :type data_subtype: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._listen_data_serialize(
            asset_id=asset_id,
            data_subtype=data_subtype,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataListen",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _listen_data_serialize(
        self,
        asset_id,
        data_subtype,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if data_subtype is not None:
            
            _query_params.append(('dataSubtype', data_subtype))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-listener',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_bulk_data(
        self,
        data: List[Data],
        direct_mode: Annotated[Optional[StrictStr], Field(description="Executes the operation directly without using other services.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Create or update multiple asset data

        Create multiple asset data or update data if already exists. Uses the unique combination of asset id and subtype for updating.

        :param data: (required)
        :type data: List[Data]
        :param direct_mode: Executes the operation directly without using other services.
        :type direct_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_bulk_data_serialize(
            data=data,
            direct_mode=direct_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_bulk_data_with_http_info(
        self,
        data: List[Data],
        direct_mode: Annotated[Optional[StrictStr], Field(description="Executes the operation directly without using other services.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Create or update multiple asset data

        Create multiple asset data or update data if already exists. Uses the unique combination of asset id and subtype for updating.

        :param data: (required)
        :type data: List[Data]
        :param direct_mode: Executes the operation directly without using other services.
        :type direct_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_bulk_data_serialize(
            data=data,
            direct_mode=direct_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_bulk_data_without_preload_content(
        self,
        data: List[Data],
        direct_mode: Annotated[Optional[StrictStr], Field(description="Executes the operation directly without using other services.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or update multiple asset data

        Create multiple asset data or update data if already exists. Uses the unique combination of asset id and subtype for updating.

        :param data: (required)
        :type data: List[Data]
        :param direct_mode: Executes the operation directly without using other services.
        :type direct_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_bulk_data_serialize(
            data=data,
            direct_mode=direct_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_bulk_data_serialize(
        self,
        data,
        direct_mode,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'Data': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if direct_mode is not None:
            
            _query_params.append(('directMode', direct_mode))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if data is not None:
            _body_params = data



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/data-bulk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_data(
        self,
        data: Data,
        direct_mode: Annotated[Optional[StrictStr], Field(description="Executes the operation directly without using other services.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Create or update asset data

        Create new asset data or update data if already exists. Uses the unique combination of asset id and subtype for updating.

        :param data: (required)
        :type data: Data
        :param direct_mode: Executes the operation directly without using other services.
        :type direct_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_data_serialize(
            data=data,
            direct_mode=direct_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_data_with_http_info(
        self,
        data: Data,
        direct_mode: Annotated[Optional[StrictStr], Field(description="Executes the operation directly without using other services.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Create or update asset data

        Create new asset data or update data if already exists. Uses the unique combination of asset id and subtype for updating.

        :param data: (required)
        :type data: Data
        :param direct_mode: Executes the operation directly without using other services.
        :type direct_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_data_serialize(
            data=data,
            direct_mode=direct_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_data_without_preload_content(
        self,
        data: Data,
        direct_mode: Annotated[Optional[StrictStr], Field(description="Executes the operation directly without using other services.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or update asset data

        Create new asset data or update data if already exists. Uses the unique combination of asset id and subtype for updating.

        :param data: (required)
        :type data: Data
        :param direct_mode: Executes the operation directly without using other services.
        :type direct_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_data_serialize(
            data=data,
            direct_mode=direct_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_data_serialize(
        self,
        data,
        direct_mode,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if direct_mode is not None:
            
            _query_params.append(('directMode', direct_mode))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if data is not None:
            _body_params = data



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_data_trend(
        self,
        data: Data,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Data:
        """Create or update historical data

        This creates or updates historical data. The choice between updating or creating depends on whether the historical  data for assetId, subtype, parameter and timestamp already exists. 

        :param data: (required)
        :type data: Data
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_data_trend_serialize(
            data=data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Data",
            '422': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_data_trend_with_http_info(
        self,
        data: Data,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Data]:
        """Create or update historical data

        This creates or updates historical data. The choice between updating or creating depends on whether the historical  data for assetId, subtype, parameter and timestamp already exists. 

        :param data: (required)
        :type data: Data
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_data_trend_serialize(
            data=data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Data",
            '422': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_data_trend_without_preload_content(
        self,
        data: Data,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or update historical data

        This creates or updates historical data. The choice between updating or creating depends on whether the historical  data for assetId, subtype, parameter and timestamp already exists. 

        :param data: (required)
        :type data: Data
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_data_trend_serialize(
            data=data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Data",
            '422': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_data_trend_serialize(
        self,
        data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if data is not None:
            _body_params = data


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/data-trend',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


